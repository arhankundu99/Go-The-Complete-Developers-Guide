# Section 2: A Simple Start

1. Run 'go' command in terminal to get the list of available options with the cli.

2. To know more about any command, use ```go help <command>```. Eg., ```go help install```.

Some of the important commands are

1. ```go build```: This command builds the executable.
2. ```go run```: This command is used to compile and run Go programs without explicitly creating an executable file. It compiles the Go source code in memory, links it, and then runs the resulting executable.
3. ```go fmt```: This command is used to format code in all files present in current directory. 
4. ```go install```: This command is used to compile and install a package (Revisit this)
5. ```go get```: This command is used to download the raw source code of someone else's package
6. ```go test```: This command is used to execute any test files that we have in our package.

## How do we run the code?

We can run the code using ```go run <file-name>```, or using ```go build <file-name>``` and then running the executable.

## What does 'package main' mean?
We can think of packages as a collection of common source code files. However ```package main``` command is reserved. The file which has the ```main``` function has to have the ```package main``` command. Otherwise, we won't be able to build / run our code. 

We can have packages with other names which would be used as a library.

## What does 'import fmt' mean?
```import <package-name>```: This command is used to give access of the package code to our package.

For eg.,

```go
package main
import "fmt" // This means that our "main" package would have access to "fmt" functionalities
```

fmt stands for format. It basically has functionalities to formatted Input Ouput in console or a file. <b>It is analogous to printf in C / C++.</b>

Always refer to official documentation.



## Comparison with C / C++
### Compilation process of C / C++
The process of compilation of C / C++ involves several steps. And as we know, there are generally frontend and backend parts of a compiler. (For eg., clang is a compiler frontend from LLVM)

#### Responsibilities of compiler frontend
Compiler frontend is responsible for ```preprocessing```, ```lexical analysis```, ```AST generation``` and ```semantic analysis```. 

1. ```Preprocessing```: Here the header files, macros etc are expanded, conditional preprocessing takes place (```ifndef```, ```define``` etc) and comments are removed. After preprocessing, a ```.i``` file is generated.

    Command for generating the preprocessed file: ```g++ -E example.c -o example.i```, 
E flag means "preprocess only"

2. Then after this, ```lexical analysis``` takes place where lexical tokens of our code is generated. For eg., int a = 5; In this statement, ['int', 'a', '=', '5'] are tokens.

3. And then, with the help of lexical tokens, an ```AST``` is generated. And after the generation, ```semantic analysis``` takes place. Semantic analysis includes ```type checking```, ```variable declaration before use``` etc.

#### Responsibilities of compiler backend

1. Compiler backend is responsible to take the AST generated by the compiler frontend, and then converts it into ```Intermidiate Representation (IR)```, where most of the optimizations like ```O3``` are applied. Note: ```O0``` means no optimization, ```O1``` for basic optimizations and so on. ```O3``` is the most aggresive optimization.

    O3 includes optimizations like:
    
    1. Function inlining
    2. Loop unrolling
    3. Other optimizations like cache etc

2. Then the compiler compiles the IR to the assembly code. At the end of this step, A ```.s``` file is generated. 

    Command to generate the .s file: ```g++ -S example.cpp```

2. And then after compiling, ```assembler``` takes the assembly code and generates machine code (.o code).

    Command to generate the .o file: ```g++ -c example.cpp```

3. And finally, the ```linking``` process takes place where the linker finds the definitions of the declared functions in other object codes are builds a standalone executable.

    During linking phase also, we can apply optimization flag like ```lto```. It is similar to ```O3```, but for linking phases. The limitation with O3 is that It can do function inlining in a single file, but during linking, the linker has the complete program view. So it can inline functions which are defined in another source files also.

    For eg., we use a function called ```foo``` in ```main.cpp```, where ```foo``` is defined in ```utils.cpp```. Now during O3 optimization, ```foo``` can't be inlined in main.cpp, but during linking phase, foo can be inlined.


Note: While optimizations like O3 and lto improve performance, these would lead to higher executable size and also longer compile times.

### Compilation process of Go

Go has somewhat different compilation process that C / C++. 

#### Responsibilities of compiler frontend
1. ```Parsing```: Here parsing of go files take place. Since there are no header files, no preprocessor declaratives, no macros, there is ```no preprocessor``` step. Lexical tokens are then generated and from those tokens ```AST``` is generated. 

2. After the generation of ```AST```, ```semantic analysis``` takes place where ```type checking```, ```variable declaration after use``` etc are done.

#### Responsibilities of compiler backend.

1. After the AST generation, the compiler backend transforms the AST to ```IR (Intermidiate Representation)```, This is where the optimizations are applied (Like loop unrolling, function inlining etc).

2. Then the IR is directly converted into ```machine code``` unlike C++ compilation process which converts into assembly code.

3. In Go, an object file is created for each package. And then in linking phase, these object files are linked to create the final executable.


<table>
    <tr>
        <td>
            Go Compilation
        </td>
        <td>
            C++ Compilation
        </td>
    </tr>
    <tr>
        <td>
            Compilation times are faster because there is no preprocessing step involved. (No headers, macros etc) and also no conversion of IR To assembly code.
        </td>
        <td>
            Compilation times are slower than Go.
        </td>
    </tr>
    <tr>
        <td>
            No separate headers. Reduces overhead of maintaining separate header files for declarations.
        </td>
        <td>
            Using C++ headers, we can seperate declarations from definitions, thus keeping the code modular.
        </td>
    </tr>
    <tr>
        <td>
            Go does not do optimations like aggressive function inlining, loop unrolling to achieve more performance. Because go compiler's priority is faster compilation times.
        </td>
        <td>
            C++ compiler provides optimizations like O3 which has aggressive loop unrolling, function inlining etc which leads to more performance at the cost of higher binary size.
        </td>
    </tr>
    <tr>
        <td>
            Go does not produce assembly code in its compilation process. Instead it directly converts into machine code.
        </td>
        <td>
            C++ produces assembly code in the compilation step.
        </td>
    </tr>
    <tr>
        <td>
            Flexibility of debugging like C++ is not present.
        </td>
        <td>
            Assembly code serves as a useful tool for debugging. It's way easier for developers to debug in assembly code rather than directly checking the machine code
        </td>
    </tr>
    <tr>
        <td>
            Flexibility of applying optimizations is not present. 
        </td>
        <td>
            In assembly code, optimizations to the code can be more easily implemented.
        </td>
    </tr>
</table>